/* autogenerated by Processing revision 1292 on 2023-03-01 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class FlowField extends PApplet {

int windowSizeX = 1920;
int windowSizeY = 1080;
int bgColor = color(0, 0, 0, 100);

int gridResolution = 5;
int gridMargin = 100;
int nRows;
int nColumns;
float[][] Grid;
int arrowLength = 15;
int arrowColor = color(255, 255, 255);

float noiseScale = 20;

int nPoints = 1000;
PVector[][] Points;
int[] Colors;
float stepLength = 10;

float Time = 0;
float timeStep = 0.1f;
float timeMax = 200;

boolean showGrid = false;

public void drawArrow(int cx, int cy, int len, float angle, int c) {
  pushMatrix();
  translate(cx, cy);
  rotate(angle);
  stroke(c);
  line(0, 0, len, 0);
  line(len, 0, len - 4, -4);
  line(len, 0, len - 4, 4);
  popMatrix();
}

public void initGrid() {
  nRows = (int)(windowSizeY + gridMargin) / gridResolution;
  nColumns = (int)(windowSizeX + gridMargin) / gridResolution;

  Grid = new float[nRows][nColumns];

  for (int i = 0; i < nRows; i++) {
    for (int j = 0; j < nColumns; j++) {
      Grid[i][j] = 0.0f;
    }
  }
}

public void updateGrid() {
  for (int i = 0; i < nRows; i++) {
    for (int j = 0; j < nColumns; j++) {
      Grid[i][j] = noise(j/noiseScale, i/noiseScale, Time/noiseScale) * 2 * PI;
    }
  }
}

public void drawGrid() {
  for (int i = 0; i < nRows; i++) {
    for (int j = 0; j < nColumns; j++) {
      float angle = Grid[i][j];
      int y = (i * gridResolution);
      int x = (j * gridResolution);
      drawArrow(x, y, arrowLength, angle, arrowColor);
    }
  }
}

public void initPoints() {
  Points = new PVector[2][nPoints];
  for (int i = 0; i < nPoints; i++) {
    Points[0][i] = new PVector(windowSizeX + gridMargin, random(windowSizeY + gridMargin));
    Points[1][i] = Points[0][i].copy();
  }
}

public void updatePoints() {
  for (int i = 0; i < nPoints; i++) {
    int rowIndex =(int)Points[0][i].y / gridResolution;
    int columnIndex =(int)Points[0][i].x / gridResolution;
    rowIndex = min(rowIndex, nRows - 1);
    columnIndex = min(columnIndex, nColumns - 1);
    float angle = Grid[rowIndex][columnIndex];

    float newX = Points[0][i].x + stepLength * cos(angle);
    float newY = Points[0][i].y + stepLength * sin(angle);

    if (newX > windowSizeX + gridMargin || newY > windowSizeY + gridMargin || newX < 0 || newY < 0) {
      newX = windowSizeX + gridMargin;
      newY = random(windowSizeY + gridMargin);

      Points[0][i].x = newX;
      Points[0][i].y = newY;

      Points[1][i].x = newX;
      Points[1][i].y = newY;
    } else {
      Points[1][i].x = Points[0][i].x;
      Points[1][i].y = Points[0][i].y;

      Points[0][i].x = newX;
      Points[0][i].y = newY;
    }
  }
}

public void drawPoints() {
  for (int i = 0; i < nPoints; i++) {
    stroke(Colors[i]);
    strokeWeight(3);
    line(Points[1][i].x, Points[1][i].y, Points[0][i].x, Points[0][i].y);
  }
}

public void initColors(int c1, int c2) {
  Colors = new int[nPoints];
  for (int i = 0; i < nPoints; i++) {
    float inter = map(i, 0, nPoints-1, 0, 1);
    Colors[i] = lerpColor(c1, c2, inter);
  }
}

public void settings() {
  size(windowSizeX, windowSizeY);
}
public void setup() {
  background(bgColor);

  initGrid();
  initPoints();
  initColors(color(0xFF7EE8F5, 5), color(0xFFF27EF5, 5));
}

public void draw() {
  if (Time < timeMax) {
    updateGrid();
    if (showGrid) {
      drawGrid();
    }
    updatePoints();
    drawPoints();

    Time = Time + timeStep;
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "FlowField" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
